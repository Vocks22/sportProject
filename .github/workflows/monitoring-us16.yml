name: US1.6 - Production Monitoring & Health Checks

on:
  schedule:
    # Run every 15 minutes during business hours (9-17 UTC)
    - cron: '*/15 9-17 * * 1-5'
    # Run every hour outside business hours
    - cron: '0 * * * *'
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      duration_minutes:
        description: 'Monitoring duration (minutes)'
        required: false
        default: '60'
        type: string
      alert_threshold:
        description: 'Alert threshold (% failures)'
        required: false
        default: '20'
        type: string

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18.x'

jobs:
  # ========================================
  # HEALTH MONITORING
  # ========================================
  health-monitoring:
    name: 🏥 Health & Performance Monitoring
    runs-on: ubuntu-latest

    strategy:
      matrix:
        environment: 
          - ${{ github.event.inputs.environment || 'production' }}
        include:
          - environment: staging
            url: https://diettracker-staging.herokuapp.com
            database_check: true
          - environment: production
            url: https://diettracker-app.herokuapp.com
            database_check: true

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install monitoring dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pytest aiohttp asyncio

      - name: Basic Health Check
        id: health_check
        run: |
          echo "🏥 Checking basic health..."
          
          health_url="${{ matrix.url }}/health"
          
          # Check health endpoint
          if curl -f --max-time 10 "$health_url"; then
            echo "::set-output name=health_status::healthy"
            health_status="healthy"
          else
            echo "::set-output name=health_status::unhealthy"
            health_status="unhealthy"
          fi
          
          echo "Health status: $health_status"

      - name: US1.6 Specific API Monitoring
        id: us16_monitoring
        run: |
          echo "📅 Monitoring US1.6 Calendar functionality..."
          
          base_url="${{ matrix.url }}/api"
          
          # Test date utils endpoints
          python -c "
          import requests
          import json
          from datetime import date, timedelta
          
          base_url = '$base_url'
          results = {
              'meal_plans_api': False,
              'calendar_navigation': False,
              'week_start_validation': False,
              'response_times': {}
          }
          
          try:
              # Test meal plans API with week_start parameter
              import time
              start_time = time.time()
              
              # Get current Monday
              today = date.today()
              monday = today - timedelta(days=today.weekday())
              
              response = requests.get(
                  f'{base_url}/meal-plans',
                  params={'week_start': monday.isoformat()},
                  timeout=10
              )
              
              results['response_times']['meal_plans'] = time.time() - start_time
              
              if response.status_code == 200:
                  results['meal_plans_api'] = True
                  data = response.json()
                  
                  # Validate week_start logic
                  if 'meal_plans' in data:
                      results['week_start_validation'] = True
              
              # Test calendar navigation
              start_time = time.time()
              next_week = monday + timedelta(days=7)
              
              response = requests.get(
                  f'{base_url}/meal-plans',
                  params={'week_start': next_week.isoformat()},
                  timeout=10
              )
              
              results['response_times']['calendar_nav'] = time.time() - start_time
              
              if response.status_code == 200:
                  results['calendar_navigation'] = True
          
          except Exception as e:
              print(f'Monitoring error: {e}')
          
          # Output results
          print(f'::set-output name=meal_plans_api::{results[\"meal_plans_api\"]}')
          print(f'::set-output name=calendar_navigation::{results[\"calendar_navigation\"]}')
          print(f'::set-output name=week_start_validation::{results[\"week_start_validation\"]}')
          print(f'::set-output name=meal_plans_response_time::{results[\"response_times\"].get(\"meal_plans\", 999)}')
          print(f'::set-output name=calendar_nav_response_time::{results[\"response_times\"].get(\"calendar_nav\", 999)}')
          
          print('US1.6 API Monitoring Results:')
          print(json.dumps(results, indent=2))
          "

      - name: Performance Benchmarks
        id: performance
        run: |
          echo "⚡ Running performance benchmarks..."
          
          python -c "
          import requests
          import time
          import statistics
          
          base_url = '${{ matrix.url }}/api'
          
          # Test multiple requests to get average response time
          response_times = []
          
          for i in range(5):
              try:
                  start_time = time.time()
                  response = requests.get(f'{base_url}/health', timeout=10)
                  end_time = time.time()
                  
                  if response.status_code == 200:
                      response_times.append(end_time - start_time)
              except:
                  response_times.append(999)  # Failed request
          
          avg_response_time = statistics.mean(response_times) * 1000  # Convert to ms
          p95_response_time = statistics.quantiles(response_times, n=20)[18] * 1000 if len(response_times) >= 5 else 999
          
          print(f'::set-output name=avg_response_time::{avg_response_time:.2f}')
          print(f'::set-output name=p95_response_time::{p95_response_time:.2f}')
          
          print(f'Average response time: {avg_response_time:.2f}ms')
          print(f'P95 response time: {p95_response_time:.2f}ms')
          "

      - name: Database Health Check
        if: matrix.database_check
        id: database_health
        run: |
          echo "🗃️ Checking database health..."
          
          # This would normally connect to your database
          # For now, we'll check via API
          python -c "
          import requests
          
          try:
              # Test an endpoint that requires database access
              response = requests.get('${{ matrix.url }}/api/recipes', timeout=15)
              
              if response.status_code == 200:
                  data = response.json()
                  if 'recipes' in data:
                      print('::set-output name=database_status::healthy')
                      print('Database status: healthy')
                  else:
                      print('::set-output name=database_status::degraded')
                      print('Database status: degraded')
              else:
                  print('::set-output name=database_status::unhealthy')
                  print('Database status: unhealthy')
                  
          except Exception as e:
              print(f'Database check failed: {e}')
              print('::set-output name=database_status::unhealthy')
              print('Database status: unhealthy')
          "

      - name: Generate Health Report
        run: |
          echo "📊 Generating health report..."
          
          cat > health-report-${{ matrix.environment }}.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "${{ matrix.environment }}",
            "health_checks": {
              "basic_health": "${{ steps.health_check.outputs.health_status }}",
              "database": "${{ steps.database_health.outputs.database_status }}",
              "us16_features": {
                "meal_plans_api": ${{ steps.us16_monitoring.outputs.meal_plans_api }},
                "calendar_navigation": ${{ steps.us16_monitoring.outputs.calendar_navigation }},
                "week_start_validation": ${{ steps.us16_monitoring.outputs.week_start_validation }}
              }
            },
            "performance": {
              "avg_response_time_ms": ${{ steps.performance.outputs.avg_response_time }},
              "p95_response_time_ms": ${{ steps.performance.outputs.p95_response_time }},
              "meal_plans_response_time_ms": ${{ steps.us16_monitoring.outputs.meal_plans_response_time }},
              "calendar_nav_response_time_ms": ${{ steps.us16_monitoring.outputs.calendar_nav_response_time }}
            },
            "alerts": {
              "health_critical": $([ "${{ steps.health_check.outputs.health_status }}" = "unhealthy" ] && echo "true" || echo "false"),
              "performance_degraded": $([ "$(echo "${{ steps.performance.outputs.avg_response_time }} > 500" | bc -l)" = "1" ] && echo "true" || echo "false"),
              "database_issues": $([ "${{ steps.database_health.outputs.database_status }}" != "healthy" ] && echo "true" || echo "false")
            }
          }
          EOF
          
          cat health-report-${{ matrix.environment }}.json

      - name: Upload Health Report
        uses: actions/upload-artifact@v4
        with:
          name: health-report-${{ matrix.environment }}-${{ github.run_number }}
          path: health-report-${{ matrix.environment }}.json
          retention-days: 30

      - name: Check Alert Thresholds
        id: alerts
        run: |
          # Check if we need to trigger alerts
          health_status="${{ steps.health_check.outputs.health_status }}"
          database_status="${{ steps.database_health.outputs.database_status }}"
          avg_response_time="${{ steps.performance.outputs.avg_response_time }}"
          
          alert_needed=false
          alert_message=""
          
          if [ "$health_status" != "healthy" ]; then
            alert_needed=true
            alert_message="Health check failed"
          fi
          
          if [ "$database_status" != "healthy" ]; then
            alert_needed=true
            alert_message="${alert_message} Database issues detected"
          fi
          
          # Check if response time exceeds threshold (500ms)
          if [ "$(echo "$avg_response_time > 500" | bc -l)" = "1" ]; then
            alert_needed=true
            alert_message="${alert_message} Performance degraded (${avg_response_time}ms avg)"
          fi
          
          echo "::set-output name=alert_needed::$alert_needed"
          echo "::set-output name=alert_message::$alert_message"
          
          echo "Alert needed: $alert_needed"
          echo "Alert message: $alert_message"

  # ========================================
  # EXTENDED MONITORING
  # ========================================
  extended-monitoring:
    name: 📈 Extended Performance Monitoring  
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests asyncio aiohttp

      - name: Extended Load Testing
        run: |
          echo "🔄 Running extended load testing for ${{ github.event.inputs.duration_minutes }} minutes..."
          
          python -c "
          import asyncio
          import aiohttp
          import time
          import json
          from datetime import datetime, timedelta
          
          async def make_request(session, url):
              try:
                  start_time = time.time()
                  async with session.get(url, timeout=10) as response:
                      end_time = time.time()
                      return {
                          'status': response.status,
                          'response_time': end_time - start_time,
                          'timestamp': datetime.now().isoformat()
                      }
              except Exception as e:
                  return {
                      'status': 0,
                      'response_time': 999,
                      'error': str(e),
                      'timestamp': datetime.now().isoformat()
                  }
          
          async def extended_monitoring():
              environment = '${{ github.event.inputs.environment || \"production\" }}'
              duration = int('${{ github.event.inputs.duration_minutes || \"60\" }}')
              
              if environment == 'production':
                  base_url = 'https://diettracker-app.herokuapp.com'
              else:
                  base_url = 'https://diettracker-staging.herokuapp.com'
              
              endpoints = [
                  f'{base_url}/health',
                  f'{base_url}/api/meal-plans',
                  f'{base_url}/api/recipes'
              ]
              
              results = []
              end_time = time.time() + (duration * 60)
              
              async with aiohttp.ClientSession() as session:
                  while time.time() < end_time:
                      # Make requests to all endpoints
                      tasks = []
                      for endpoint in endpoints:
                          tasks.append(make_request(session, endpoint))
                      
                      batch_results = await asyncio.gather(*tasks)
                      results.extend(batch_results)
                      
                      # Wait 30 seconds between batches
                      await asyncio.sleep(30)
              
              # Analyze results
              total_requests = len(results)
              successful_requests = sum(1 for r in results if r['status'] == 200)
              failed_requests = total_requests - successful_requests
              
              if total_requests > 0:
                  success_rate = (successful_requests / total_requests) * 100
                  avg_response_time = sum(r['response_time'] for r in results if r['response_time'] < 999) / successful_requests if successful_requests > 0 else 999
              else:
                  success_rate = 0
                  avg_response_time = 999
              
              report = {
                  'monitoring_duration_minutes': duration,
                  'total_requests': total_requests,
                  'successful_requests': successful_requests,
                  'failed_requests': failed_requests,
                  'success_rate_percent': success_rate,
                  'avg_response_time_seconds': avg_response_time,
                  'alert_threshold_percent': int('${{ github.event.inputs.alert_threshold || \"20\" }}')
              }
              
              print('Extended Monitoring Report:')
              print(json.dumps(report, indent=2))
              
              # Check if alert is needed
              alert_threshold = int('${{ github.event.inputs.alert_threshold || \"20\" }}')
              if (100 - success_rate) > alert_threshold:
                  print(f'::set-output name=extended_alert_needed::true')
                  print(f'::set-output name=extended_alert_message::Failure rate {100-success_rate:.1f}% exceeds threshold {alert_threshold}%')
              else:
                  print(f'::set-output name=extended_alert_needed::false')
                  print(f'::set-output name=extended_alert_message::System performing within acceptable limits')
              
              # Save detailed report
              with open('extended-monitoring-report.json', 'w') as f:
                  json.dump({**report, 'detailed_results': results}, f, indent=2)
          
          asyncio.run(extended_monitoring())
          "

      - name: Upload Extended Monitoring Report
        uses: actions/upload-artifact@v4
        with:
          name: extended-monitoring-report-${{ github.run_number }}
          path: extended-monitoring-report.json
          retention-days: 90

  # ========================================
  # ALERTING
  # ========================================
  send-alerts:
    name: 🚨 Send Monitoring Alerts
    runs-on: ubuntu-latest
    needs: health-monitoring
    if: needs.health-monitoring.outputs.alert_needed == 'true'

    steps:
      - name: Send Slack Alert
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            🚨 **US1.6 Production Monitoring Alert**
            
            **Environment**: ${{ matrix.environment || 'production' }}
            **Issue**: ${{ needs.health-monitoring.outputs.alert_message }}
            **Time**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
            
            **Health Status**:
            - Basic Health: ${{ needs.health-monitoring.outputs.health_status }}
            - Database: ${{ needs.health-monitoring.outputs.database_status }}
            - Avg Response Time: ${{ needs.health-monitoring.outputs.avg_response_time }}ms
            
            **US1.6 Features**:
            - Meal Plans API: ${{ needs.health-monitoring.outputs.meal_plans_api }}
            - Calendar Navigation: ${{ needs.health-monitoring.outputs.calendar_navigation }}
            - Week Start Validation: ${{ needs.health-monitoring.outputs.week_start_validation }}
            
            Please investigate immediately!
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create Monitoring Issue
        if: contains(needs.health-monitoring.outputs.alert_message, 'failed')
        uses: actions/github-script@v6
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 US1.6 Monitoring Alert: System Health Issue',
              body: `# System Health Alert
              
              **Environment**: Production
              **Alert Time**: ${new Date().toISOString()}
              **Issue**: ${{ needs.health-monitoring.outputs.alert_message }}
              
              ## Health Check Results
              - Basic Health: ${{ needs.health-monitoring.outputs.health_status }}
              - Database: ${{ needs.health-monitoring.outputs.database_status }}
              - Average Response Time: ${{ needs.health-monitoring.outputs.avg_response_time }}ms
              
              ## US1.6 Feature Status
              - Meal Plans API: ${{ needs.health-monitoring.outputs.meal_plans_api }}
              - Calendar Navigation: ${{ needs.health-monitoring.outputs.calendar_navigation }}
              - Week Start Validation: ${{ needs.health-monitoring.outputs.week_start_validation }}
              
              ## Actions Required
              - [ ] Investigate root cause
              - [ ] Check server logs
              - [ ] Verify database connectivity
              - [ ] Test US1.6 calendar features manually
              - [ ] Update team on resolution
              
              /cc @devops-team @oncall`,
              labels: ['monitoring', 'health-check', 'us16', 'alert']
            });
            
            console.log('Created monitoring issue:', issue.data.html_url);

  # ========================================
  # MONITORING SUMMARY
  # ========================================
  monitoring-summary:
    name: 📊 Monitoring Summary
    runs-on: ubuntu-latest
    needs: [health-monitoring, extended-monitoring]
    if: always()

    steps:
      - name: Generate Summary Report
        run: |
          echo "📊 Generating monitoring summary..."
          
          cat > monitoring-summary.md << EOF
          # US1.6 Monitoring Summary Report
          
          **Date**: $(date -u +%Y-%m-%d)
          **Time**: $(date -u +%H:%M:%S) UTC
          **Trigger**: ${{ github.event_name }}
          
          ## Health Check Results
          
          | Metric | Status | Details |
          |--------|--------|---------|
          | Basic Health | ${{ needs.health-monitoring.outputs.health_status || 'N/A' }} | System availability |
          | Database | ${{ needs.health-monitoring.outputs.database_status || 'N/A' }} | Database connectivity |
          | Avg Response Time | ${{ needs.health-monitoring.outputs.avg_response_time || 'N/A' }}ms | API performance |
          | P95 Response Time | ${{ needs.health-monitoring.outputs.p95_response_time || 'N/A' }}ms | Performance percentile |
          
          ## US1.6 Feature Health
          
          | Feature | Status | Response Time |
          |---------|--------|---------------|
          | Meal Plans API | ${{ needs.health-monitoring.outputs.meal_plans_api || 'N/A' }} | ${{ needs.health-monitoring.outputs.meal_plans_response_time || 'N/A' }}s |
          | Calendar Navigation | ${{ needs.health-monitoring.outputs.calendar_navigation || 'N/A' }} | ${{ needs.health-monitoring.outputs.calendar_nav_response_time || 'N/A' }}s |
          | Week Start Validation | ${{ needs.health-monitoring.outputs.week_start_validation || 'N/A' }} | Functional check |
          
          ## Alerts
          
          - **Alert Triggered**: ${{ needs.health-monitoring.outputs.alert_needed || 'false' }}
          - **Alert Message**: ${{ needs.health-monitoring.outputs.alert_message || 'None' }}
          
          ## Next Steps
          
          $( if [ "${{ needs.health-monitoring.outputs.alert_needed }}" = "true" ]; then
            echo "🚨 **Action Required**: Issues detected - investigate immediately"
          else
            echo "✅ **All Good**: System operating normally"
          fi )
          
          ---
          *Generated by US1.6 Monitoring Pipeline*
          EOF
          
          cat monitoring-summary.md

      - name: Upload Summary Report
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-summary-${{ github.run_number }}
          path: monitoring-summary.md
          retention-days: 30